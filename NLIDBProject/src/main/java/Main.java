

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.StringReader;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import ComponentDependencyParser.NLPDependencyParser;
import ComponentDependencyParser.NLPParseTreeResult;
import ComponentNodeMapper.NodeMapperParser;
import ComponentQueryTranslator.QueryTreeTranslator;
import ComponentStructureAdjustor.StructureAdjustor;
import Model.Node;
import Model.NodeData;
import Model.ParseTreeNodeMapper;
import Model.Query;
import Model.SchemaGraph;
import Model.ParseTreeNodeMapper.ParseTreeNodeMapperIterator;
import edu.stanford.nlp.ling.HasWord;
import edu.stanford.nlp.ling.TaggedWord;
import edu.stanford.nlp.parser.nndep.DependencyParser;
import edu.stanford.nlp.process.DocumentPreprocessor;
import edu.stanford.nlp.tagger.maxent.MaxentTagger;
import edu.stanford.nlp.trees.GrammaticalStructure;

public class Main {

	public static void main(String[] args) {
		
		// Used for running the application in an loop
		boolean startApplication = true;
		
		//Buffer user to read user input
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
				//Database Connection
				
				//Load the JDBC driver
				try { Class.forName("org.mariadb.jdbc.Driver"); } 
				
				catch (ClassNotFoundException e1) { }
				
				System.out.println("MariaDB JDBC Driver Registered!");
				
				Connection connection = null;
				SchemaGraph schema = null;

				try {
					//use driver to set up DB connection
					connection = DriverManager.getConnection("jdbc:mariadb:://127.0.0.1:3306/mas", "root", "");
				} catch (SQLException e) {
					e.printStackTrace();
				}
				System.out.println("Connection successful!");
				
				//Generate a schema graph of the database
				//schema will hold our database schema within our program
				try {
					schema = new SchemaGraph(connection);
					System.out.println("Database Schema:\n\n"+schema.toString());
				} catch (SQLException e) {
					e.printStackTrace();
				}

		//Application Loop
		while(startApplication) {
			System.out.println("Enter your query : ");
			String query = "";
			try {
				query = br.readLine();
			} catch (NumberFormatException | IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			
			//Main program used for pipelining the components
			NLDBParser(query, connection, schema);
			
		}

		
				


	}

	//Main Program that runs all the components
	public static void NLDBParser(String text, Connection connection, SchemaGraph schema) {
		
				//Special Characters preprocessing
				if(text.contains("\"")) {
					//Removes quotes in present
					String words1 = text.split("\"")[0];
					//Split query based on spaces
					String beforeCondition = words1.split(" ")[words1.split(" ").length-1];
					//if there is an "of" keyword before the quotes
					if(beforeCondition.equals("of")) {
						String[] words1Array = words1.split(" ");
						words1 = "";
						for (int i = 0; i < words1Array.length; i++) {
							if(i ==  words1Array.length-1) {
								//special case where replace the word "of" with the word "equal"
								//"of" can either be meaningless of a keyword
								words1 += "equal" + " ";
							}
							else {
								words1 += words1Array[i] + " ";
							}
						}
				
					}
					//Used to process blocks in quotes. for example: "North America" will be North!America
					//This will allow word to be processed together for dependency parser
					String words2 = text.split("\"")[1].replace("\"", "");
					text = words1 + words2.replace(" ", "!").replace(".", "");
				}
				
				//COMPONENT 1: NLP Dependency parser
				NLPDependencyParser dp = new NLPDependencyParser(text);
				//Parse tree result generated by the NLP library
				NLPParseTreeResult nlpresult = dp.parseText();
				
				//remove exclamation points for quotes after processing by the NLP library
				if(text.contains("!")) {
					text = text.replace("!", " ");
				}
				
				System.out.println("");
				System.out.println("Text to translate : " + text);
				System.out.println("");
				System.out.println("NLP Parse Tree Component 1");
				System.out.println(nlpresult.getGrammaticalStructure());
				
				//Parse Tree generation
				//builds parse tree based on generated tag, gramatical structure and sentence generated in component 1 
				ParseTreeNodeMapper parseTree = new ParseTreeNodeMapper(nlpresult.getTagged(), nlpresult.getSentence(), nlpresult.getGrammaticalStructure());
				Node[] nodes = parseTree.getNodes();
				System.out.println("");
				System.out.println("Parse Tree Node Mapper Component 2");
				for (int i = 0; i < nodes.length; i++) {
					//Print out all the nodes of the NLP parse tree for us to see
					System.out.println("Nodes : " + nodes[i]);
				}
						
				//COMPONENT 2: Node Mapper 
				//Used to initialize at first here
				NodeMapperParser nodeMapper = null;
				try { 
					nodeMapper = new NodeMapperParser();
					boolean mappingNodes = false;
				} catch (Exception e) { 
					e.printStackTrace(); 
				}
				
				ParseTreeNodeMapperIterator iteration = parseTree.iterator();
				//gets user input for choice (Interactive or not)
				BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
				
				System.out.println("");
				System.out.println("Enable Interactive Communicator 1 for Yes, 0 for No : ");
				
				//If we choose to use the interactive communicator
				int ICChoice = 1;
				try {
					//read user choice of ICC or not
					ICChoice = Integer.parseInt(br.readLine());
				} catch (NumberFormatException | IOException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				//list to store the Interactive communicator choices
				List<NodeData> choices = null;
				
				//Loop on our parse tree nodes to show the mapping of the nodes
				//and to get the node possible choices
				for(int i=0; i<parseTree.getNodes().length; i++) {
					Node node = parseTree.getNodes()[i];
					//save the data choice for the node mapper
					
					//Generate the choices possible of a node
					//Check by clicking on function to see details on how choices are proposed
					//In ICC mode, we get and keep choice list, in non-ICC we only base ourselves on score
					choices = nodeMapper.getNodeDataChoices(node, schema);
				}
				
				//When choices are generated, we add the meaningless node
				NodeData unkownNode = new NodeData("UNKNOWN","meaningless");
				
				//score of choice go from 0 to 1
				unkownNode.setScore(0.1);
				
				//Add unknown node to mapping
				choices.add(unkownNode);

				boolean isMapped = false;
				int nodeNumber = 0;
				
				//Sort choices by alphabetical order
				Collections.sort(choices);
				
				//Initializing the query result for later
				String queryResult = "";
				
				//if we choose the ICC
				if(ICChoice == 1) {
					//For each node
					while(nodeNumber !=  (parseTree.getNodes().length)) {
						for(int i=0; i<choices.size(); i++) {
							//We will display every choice available
							System.out.println("Node Mapping Choice Type " + i + " : " + choices.get(i).getValue());
						}
						//If it is not a keyword (like return ect...), we will prompt the user for that word
						if(!nodeMapper.mappingRules.containsKey(parseTree.getNodes()[nodeNumber].getWord()) && !parseTree.getNodes()[nodeNumber].getWord().equals("ROOT")){
							System.out.println("Node : " + parseTree.getNodes()[nodeNumber].toString());
							System.out.println("Your mapping choice for the node : ");
							int choiceNumber = 0;
							try {
								choiceNumber = Integer.parseInt(br.readLine());
							} catch (NumberFormatException | IOException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							parseTree.getNodes()[nodeNumber].setInfo(new NodeData(choices.get(choiceNumber).getType() , choices.get(choiceNumber).getValue()));
							System.out.println("-------------------------");
						}
						//Verify if it is a root node. If it is, no need to ask user
						else if(parseTree.getNodes()[nodeNumber].getWord().equals("ROOT")) {
							System.out.println("Node : " + parseTree.getNodes()[nodeNumber].toString());
							parseTree.getNodes()[nodeNumber].setInfo(new NodeData("ROOT", "ROOT"));
							System.out.println("Node Mapped with : " + parseTree.getNodes()[nodeNumber].getData().toString());
						}
						//Else it is a keyword and we map it with keyword (like return will be mapped to SELECT)
						else {
							System.out.println("Node : " + parseTree.getNodes()[nodeNumber].toString());
							System.out.println("Node Mapped with : " + nodeMapper.mappingRules.get(parseTree.getNodes()[nodeNumber].getWord()).toString());
							parseTree.getNodes()[nodeNumber].setInfo(nodeMapper.mappingRules.get(parseTree.getNodes()[nodeNumber].getWord()));
						}
						
						nodeNumber++;
					}
					

					
				}
				//if we choose no use of ICC
				else {
					while(nodeNumber !=  (parseTree.getNodes().length)) {
						
						for(int i=0; i<choices.size(); i++) {
							System.out.println("Node Mapping Choice Type " + i + " : " + choices.get(i).getValue());
							//we display the matching score of each node
							System.out.println("Node score : " + choices.get(i).getScore());
						}
						//same logic as IIC, if node is not a keyword -> we find the best score to chose as mapping
						if(!nodeMapper.mappingRules.containsKey(parseTree.getNodes()[nodeNumber].getWord()) && !parseTree.getNodes()[nodeNumber].getWord().equals("ROOT")){
							
							//By default, we intialize best score as 0
							int bestNodeScoreIndex = 0;
							double bestNodeScore = 0.0;
							boolean exactNodeIndexFound = false;
							
							//Loop to find the best score among choices
							for(int i=0; i<choices.size(); i++) {
								
				
								if(i>0 && choices.get(i).getScore() > bestNodeScore && exactNodeIndexFound == false) {
									System.out.println("Best Score : " + choices.get(i).getScore());
									bestNodeScoreIndex = i;
									bestNodeScore = choices.get(i).getScore();
								}
								
								
								if(choices.get(i).getValue().equals(parseTree.getNodes()[nodeNumber].getWord())) {
									System.out.println("Equals");
									exactNodeIndexFound = true;
									bestNodeScoreIndex = i;
								}
								
							}
							//Display node with best score
							System.out.println("Best Node Score : " + choices.get(bestNodeScoreIndex).toString());
							
							parseTree.getNodes()[nodeNumber].setInfo(new NodeData(choices.get(bestNodeScoreIndex).getType() , choices.get(bestNodeScoreIndex).getValue()));
							System.out.println("-------------------------");
						}
						//If it is a root node, no treatment needed
						else if(parseTree.getNodes()[nodeNumber].getWord().equals("ROOT")) {
							System.out.println("Node : " + parseTree.getNodes()[nodeNumber].toString());
							parseTree.getNodes()[nodeNumber].setInfo(new NodeData("ROOT", "ROOT"));
							System.out.println("Node Mapped with : " + parseTree.getNodes()[nodeNumber].getData().toString());
						}
						//If it is a keywword, we map it with keyword
						else {
							System.out.println("Node : " + parseTree.getNodes()[nodeNumber].toString());
							System.out.println("Node Mapped with : " + nodeMapper.mappingRules.get(parseTree.getNodes()[nodeNumber].getWord()).toString());
							parseTree.getNodes()[nodeNumber].setInfo(nodeMapper.mappingRules.get(parseTree.getNodes()[nodeNumber].getWord()));
						}
						
						nodeNumber++;
					}
				}
				
				//COMPONENT 3 - Structure Adjustor
				
				//We can now remove "meaningless" nodes, we don't need them anymore
				parseTree.removeUnknownNodes();
				
				System.out.println("Parse Tree before");
				System.out.println(parseTree.toString());
				System.out.println(parseTree.getNodes()[0].children.get(0).word);
				if(!parseTree.getNodes()[0].children.get(0).word.equals("return")) {
					System.out.println("Adjuste Moving");
					
					//We generate a new parse tree if return is not in first node
					ParseTreeNodeMapper newParseTree = new ParseTreeNodeMapper(parseTree);
					for (int i = 0; i < parseTree.getNodes().length; i++) {
						if(parseTree.getNodes()[i].equals("return")) {
							//We search return node and move it in beginning using the Structure Adjustor
							StructureAdjustor.moveNodes(StructureAdjustor.searchNode(newParseTree, parseTree.getNodes()[i]), StructureAdjustor.searchNode(newParseTree, parseTree.getNodes()[1]));
						}
						
					}
					System.out.println("New");
					System.out.println(newParseTree.toString());
				}
				else {
					System.out.println("Adjust return");
				}
				
				//If Generated Parse Tree does not contain return in first node
				if(!parseTree.getNodesArray()[1].getWord().equals("return")) {
					System.out.println("Return node adjustment");
					List<ParseTreeNodeMapper> adjustedReturnTreeList = StructureAdjustor.adjust(parseTree);
					for (int i = 0; i < adjustedReturnTreeList.size(); i++){
						System.out.println("Tree "+i+" :");
						//We take only parse tree that contains a return at the beginning
						if(adjustedReturnTreeList.get(i).getNodesArray()[1].getWord().equals("return")) {
							parseTree = adjustedReturnTreeList.get(i);
						}
					}

				}
				
				//Choice of adjusted parse tree
				int choiceNumber = 0;
				
				//In ICC mode, we ask the user if he wants to see adjusted parse tree to select
				if(ICChoice == 1) {
				
					System.out.println("Do you want to adjust query (1 for Yes, 0 for No)");
					System.out.println(parseTree.toString());
	
					try {
						//Read user selection (1 or 0)
						choiceNumber = Integer.parseInt(br.readLine());
					} catch (NumberFormatException | IOException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				
				}
				
				//We want no adjustment - We generate directly translation into SQL with component 5
				if(choiceNumber==0) {
					System.out.println("Query Tree");
					System.out.println(parseTree.toString());
					
					System.out.println("Query Tree Translator");
					
					//COMPONENT 4 - Query Translator
					Query query = parseTree.queryTreeToSQL(schema);
					System.out.println("Query Translator");
					System.out.println("");
					System.out.println(query.toString());
					queryResult = query.toString();
					
				}
				else {
					
					//With the adjustment
					System.out.println("Structure Adjuster");
					System.out.println("Input tree: "+parseTree.toString());
					List<ParseTreeNodeMapper> adjustedTreeList = StructureAdjustor.adjust(parseTree);
					System.out.println("Output size: "+adjustedTreeList.size());
					System.out.println("Output trees:");
					for (int i = 0; i < adjustedTreeList.size(); i++){
						//We offer all the proposed adjusted trees
						System.out.println("Tree "+i+" :");
						System.out.println(adjustedTreeList.get(i).toString());
						
					}
					
					int choice= 0;
					
					if(adjustedTreeList.size() > 0) {
					//ask user to select adjusted tree if in ICC
					if(ICChoice == 1) {
						System.out.println("Your adjusted tree choice : ");
		
						try {
							choice = Integer.parseInt(br.readLine());
						} catch (NumberFormatException | IOException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
					}

					System.out.println("Query Tree Translator");
					
					//COMPONENT 4 - We translate the query tree for our ICC scenario
					Query query = adjustedTreeList.get(choice).queryTreeToSQL(schema);
					System.out.println("Query Translator");
					System.out.println("");
					queryResult = query.toString();
					System.out.println(query.toString());
					}
					else {
						System.out.println("No query tree found");
					}
				}
				
				int choice = 0;

				System.out.println("Run the query on database 1 for Yes, 0 for No : ");

				try {
					choice = Integer.parseInt(br.readLine());
				} catch (NumberFormatException | IOException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				//If the user requests it, we run the query tree on the DB
				if(choice == 1) {
					QueryTreeTranslator.runQuery(connection, queryResult, 20);
					System.out.println("");
				}
				
			
				
	}
}
